<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="https://hibikequantum.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hibikequantum.github.io/" rel="alternate" type="text/html" /><updated>2023-08-31T23:08:35+09:00</updated><id>https://hibikequantum.github.io/feed.xml</id><title type="html">Hibike! Quantum tech blog</title><subtitle>백엔드 개발자였다가 지금은 데브옵스. 장인의 삶을 희망. 엔지니어링이든 사업이든 사물의 가치를 알아보는 멋진 사람이 되고 싶어요.</subtitle><author><name>강태훈</name></author><entry><title type="html">DevOps와 SE를 위한 리눅스커널 이야기</title><link href="https://hibikequantum.github.io/devlog/DevOps%EC%99%80SE%EB%A5%BC%EC%9C%84%ED%95%9C%EB%A6%AC%EB%88%85%EC%8A%A4%EC%BB%A4%EB%84%90%EC%9D%B4%EC%95%BC%EA%B8%B0" rel="alternate" type="text/html" title="DevOps와 SE를 위한 리눅스커널 이야기" /><published>2023-08-31T21:19:49+09:00</published><updated>2023-08-31T21:19:56+09:00</updated><id>https://hibikequantum.github.io/devlog/DevOps%EC%99%80SE%EB%A5%BC%EC%9C%84%ED%95%9C%EB%A6%AC%EB%88%85%EC%8A%A4%EC%BB%A4%EB%84%90%EC%9D%B4%EC%95%BC%EA%B8%B0</id><content type="html" xml:base="https://hibikequantum.github.io/devlog/DevOps%EC%99%80SE%EB%A5%BC%EC%9C%84%ED%95%9C%EB%A6%AC%EB%88%85%EC%8A%A4%EC%BB%A4%EB%84%90%EC%9D%B4%EC%95%BC%EA%B8%B0"><![CDATA[<p class="caption"><img src="/assets/img/IMG_4195.jpg" alt="" class="align-center" />
책표지</p>

<h2 id="책의-핵심">책의 핵심</h2>
<ol>
  <li>시스템 관리자로서 리눅스 시스템의 자원을 탐색하는 방법을 소개</li>
  <li>커널이 자원을 이용하는 방법에 관해 소개</li>
  <li>커널의 커스터마이징을 위해 제공되는 매개변수 설명</li>
  <li>TCP 프로토콜의 특성때문에 생길 수 있는 백엔드의 애로사항</li>
  <li>커널 소스를 보면서 디버깅하고 성능 최적화</li>
</ol>

<h2 id="책을-읽기-위한-준비">책을 읽기 위한 준비</h2>
<p>이 책은 초심자를 위한 책은 아니다. 컴퓨터의 자원이 뭔지는 이해하는 중급 엔지니어를 위한 책이다. 그렇다고 너무 어려운 것도 아니다. 운영체제 개론을 읽어봤고 리눅스 환경에서 네트워크 문제로 하루 정도 뒹굴어본 경험, C와 파이선 코드의 플로우를 이해할 수준이면 된다.</p>

<h2 id="만족스러운-점">만족스러운 점</h2>
<ol>
  <li>컴퓨터 과학의 기초를 배울 때 이걸 어디다 써먹나 할 때가 많았다. 하지만 이 책에선 그걸 구체적으로 문제해결이나 커스터마이징에서 활용하는걸 잘 보여주어 흥미로웠다. 마지막으로 남은 퍼즐조각이 마침내 맞춰진 느낌.</li>
  <li>저자가 수정하는 파라미터가 커널 어디서 동작하는지 알려주기 위해 부단히 코드를 보여주는데 그걸 보고 있으면 응용만 다루느라 신경쓰지 못했던 OS 자원들의 라이프사이클이 적나라하게 느껴지는 게 좋았다. 더 이상 커널의 동작이 미지의 세계가 아니게 된다.</li>
</ol>

<h2 id="어떻게-응용할것인가">어떻게 응용할것인가</h2>
<p>책에서 자원을 탐색하고 트러블슈팅을 하는 방법은 곧바로 써먹을 수 있으니까 문제가 없다. 그런데 커널 파라미터가 문제다. 기본값이 통상적인 활용에서 최적화된 경우거나 배드케이스에서도 괜찮은 퍼포먼스를 보여주기 때문에 설정되었을텐데 과연 그걸 수정해서 얻는 이익은 얼마나 될까.</p>

<p>이 책에서도 그런 염려 하는지 퍼포먼스를 떨어트릴 위험에 대해 꾸준히 경고하면서 잘 사용하는 방법에 대해 이야기를 하고 있다. 이런 염려가 없이 확실하게 선택할 수 있는 값들도 있다. 예를 들어 I/O 스케쥴러를 데드라인으로 쓸지 cfq로 쓸지는 서버의 기능에 따라 확실하고 쉽게 갈린다. 하지만 그 이상으로 NUMA, SWAPE 이런 것들은 변경에 대한 확실한 리턴이 있을 때 접근해야겠다는게 내 결론이다. (소규모 환경에선 이것까지 건드릴 여유도 없을것이다)</p>]]></content><author><name>강태훈</name></author><category term="Devlog" /><category term="Devops," /><category term="SE," /><category term="Middleware" /><summary type="html"><![CDATA[책표지]]></summary></entry><entry><title type="html">켄트 백, 테스드 주도 개발</title><link href="https://hibikequantum.github.io/devlog/TDDbyExample%EB%A6%AC%EB%B7%B0" rel="alternate" type="text/html" title="켄트 백, 테스드 주도 개발" /><published>2022-12-05T14:47:19+09:00</published><updated>2022-12-05T14:47:26+09:00</updated><id>https://hibikequantum.github.io/devlog/TDDbyExample%EB%A6%AC%EB%B7%B0</id><content type="html" xml:base="https://hibikequantum.github.io/devlog/TDDbyExample%EB%A6%AC%EB%B7%B0"><![CDATA[<p class="caption"><img src="/assets/img/IMG_3629 copy.jpg" alt="" class="align-center" />
금방 읽을 수 있는 책이다.</p>

<h2 id="책소개">책소개</h2>
<p>저자가 중얼거리는듯한 내용의 책. 난생처음으로 보는 포맷으로 쓰인 책이다. 저자와 함께 짝 프로그래밍을 하는듯한 구조로 구성된 책이다. 의식의 흐름으로 책을 써 내려가 이상한 소리도 많지만 이상하게 익숙하고 편하게 읽어지는 책이다. 예제의 절반은 자바 절반은 파이선 코드를 사용한다. 책 실제 구현을 함께 해보는 의식의 흐름으로 쓰인 2부까지가 TDD를 이해하는데 핵심이 되는 이야기이며 나머진 ‘디자인 패턴’과 ‘리팩토링’을 둘러싼 TDD 패러다임의 관계에 대한 진술이 주가 되며 관련 경험이 부족하다면 이해하기 힘든 내용이었다.</p>

<h2 id="그저-우리는-스승의-길을-따라가면-될뿐이다">그저 우리는 스승의 길을 따라가면 될뿐이다.</h2>
<p>TDD는 책만으로 배울 수 있는 이야기가 아니다. 저자도 잘 알고 있기에 그는 이 책 전반에서 이런 방법론을 마치 무술처럼 동양의 사상까지 언급해가며 제자에게 잘 설명해주며 수련을 강조한다. 따라서 이 책을 충실히 읽은 독자들에겐 남은 사명은 TDD 철학의 궁극적 목표 “1년 뒤에 봐도 부끄럽지 않은 코드”, “변경에 대한 두려움이 없는 코드”라는 실천만이 남는다. 너무 많은 실천강령으로 인해 머리가 아파지는 일반적인 방법론 서적과 비교하면 실천의 명령이 명약관화한 책. 테스트를 먼저 만들고 빨리 녹색불이 들어오게 한 다음 중복된 코드를 줄이면 된다.</p>

<p>그렇게 길지 않은 책이므로 아직 TDD의 콘셉트가 익숙하지 않은 사람이라면 볼만한 책이라고 생각한다. 이 책을 보면서 과거에 테스트 코드를 만들어야할때 겨우 이런걸 테스트해야하나 하고 고민했던 내가 바보같이 느껴졌다. ‘겨우 이런것’도 괜찮다. 그 테스트로 인해 더 어려운 테스트를 할 수 있는건데. 빨리 읽었으면 좋았을거란 생각이 너무 들었고 TDD에 대한 많은 의문을 풀게 해준 책이라 기분 좋은 책이었다.</p>]]></content><author><name>강태훈</name></author><category term="Devlog" /><category term="TDD," /><category term="방법론" /><summary type="html"><![CDATA[금방 읽을 수 있는 책이다.]]></summary></entry><entry><title type="html">Jira 프로젝트들을 독립적으로 사용하기 위해 알아야 할 지식</title><link href="https://hibikequantum.github.io/jira/JIRA-Scheme-%EC%99%84%EC%A0%84%EB%B6%84%EC%84%9D" rel="alternate" type="text/html" title="Jira 프로젝트들을 독립적으로 사용하기 위해 알아야 할 지식" /><published>2022-11-21T13:16:03+09:00</published><updated>2022-11-21T17:16:12+09:00</updated><id>https://hibikequantum.github.io/jira/JIRA-Scheme-%EC%99%84%EC%A0%84%EB%B6%84%EC%84%9D</id><content type="html" xml:base="https://hibikequantum.github.io/jira/JIRA-Scheme-%EC%99%84%EC%A0%84%EB%B6%84%EC%84%9D"><![CDATA[<h2 id="무엇을-알려주려고-쓰는-글">무엇을 알려주려고 쓰는 글?</h2>
<p>Jira에서 각자 프로젝트별로 독립된 스키마를 유지하기 위해서 명심하는건 <code class="language-plaintext highlighter-rouge">개별 Project 메인화면 - Project settings</code>에서 확인가능한 각 스키마를 단독으로 사용하는지 화면 상단에 Alert 박스로 보이는 <code class="language-plaintext highlighter-rouge">Used by n Projects</code> 부분을 잘 확인하면 된다. 단독사용이라면 ‘1’로 보일 것이다. 공통 스키마라면 공통으로 사용중인 프로젝트의 이름이 보일 것이다. 1이 아니라면 스키마를 복제해 독립하면 된다. 하지만 이런 원칙을 지켜도 가끔 프로젝트의 수정이 다른 프로젝트에 영향을 미치기도 하는 게 문제다. <strong>이 글에선 그런 문제를 유발 할 수 있는 지라의 예외적인 케이스와 잘 모르면 오해하기 쉬운 케이스</strong>로 “1. 워크플로 내부의 State, Transition 네임수정 2. Simplified workflow 기능 3. Glbal scheme” 를 소개하려고 한다.</p>

<h2 id="case-1-workflows---state-transition">CASE (1) Workflows - State, Transition</h2>
<p>명시적으로는 잘 표시가 안되어 있어서 생기는 문제인데. <strong>워크플로의 State와 Transion 이름을 수정할 경우 스키마를 무시하고 해당 이름을 사용중인 모든 Workflowrk에 영향을 미친다.</strong> 예를 들어 A 워크플로에 ‘Backlog’ 란 이름의 State를 만들어 쓰고 있는 상태에서 B 워크플로에서 ‘Backlog’란 이름의 State를 만들어 쓰다가 ‘Todo’라고 이름을 바꿀 경우 A워크플로의 ‘Backlog’ State도 ‘Todo’가 된다. 이때 리눅스 파일 시스템으로 따지자면 State, Transition 파일들은 같은 이름의 ‘원본 오브젝트’를 하드링크한 상태라고 생각하라. 이런 영향을 경고하는 메시지가 수정할 때 뜨긴 하지만 스키마가 독립되어 있다는 생각에 메시지를 무시하기가 쉽다. 따라서 이를 수정하는 것은 예상하지 못한 변경을 일으킨다.<br />
예를 들어 워크플로 A의 ‘Backlog’갯수를 대시보드에서 JQL를 통해 추적하고 있는데 ‘Backlog’의 이름이 ‘Todo’가 되면 쿼리가 깨지게 된다. 더 나쁜건 없는 상태 값을 찾는 JQL은 값을 0으로 돌려주는게 아니라 완전히 Query를 실패한 것으로 보고 응답을 주지 않아 대시보드 전체를 먹통으로 만든다.<br />
이런 문제를 피하기 위해서 만약 이름을 바꿀때 <code class="language-plaintext highlighter-rouge">다른 워크플로우에 영향을 끼친다고 경고</code>를 할경우 이름을 바꾸지 않아야한다. 그 대신 워크플로에서 새로운 오브젝트를 만들고 그 이름을 바꿀 이름으로 하는게 안전하다. 대신 지라에선 state가 사용중일땐 state를 지울 수 없으니 임시 Transition을 만들어서 새로운 이름의 Issue로 옮기면 된다. 이렇게 하면 다른 프로젝트에 간섭없이 워크플로를 수정할 수 있다.</p>

<h2 id="case-2-simplifed-workflow">CASE (2) Simplifed workflow</h2>
<p>프로젝트 생성시 <code class="language-plaintext highlighter-rouge">shared configuration</code> 또는 <code class="language-plaintext highlighter-rouge">project copy</code> 기능을 쓰지 않고 프로젝트를 생성하게 되면 <code class="language-plaintext highlighter-rouge">Software Simplified Workflow for Project &lt;이름&gt;</code>라는 워크플로가 생성되어 할당된다. 이 워크플로는 다음과 같은 description을 기본적으로 가진다. <code class="language-plaintext highlighter-rouge">Generated by JIRA Software version 7.1.9-D20151208T191112. This workflow is managed internally by JIRA Software. Do not manually modify this workflow</code> 뭔가 무서워 보이는데 이걸 수정해보면 정말로 큰일은 안난다. 이것을 수정하게 되면 무엇이 안되는가 하면 simplified workflow 기능을 쓸 수 없게 된다. (만약 수정한 상태에서 simplify workflow 기능을 쓰려고 하면 ERROR가 발생하면서 활성화 시킬 수 없다고 나온다.) 이 기능은 <code class="language-plaintext highlighter-rouge">DASHBOARD-configure-좌측 Columns</code>메뉴로 이동하면 볼 수 있다. 이 기능은 대시보드에서 컬럼과 상태 값을 만들면 그걸 workflow에 바로 반영시켜주는 기능이다. 하지만 이렇게 대시보드와 워크플로를 하나로 만들어버리면 Transition과 상태변화에 조건을 붙이는것과 같은 지라만의 컨셉이 배제된 극소적 기능만 사용하게 된다. 지라는 각 Transition에 대해서도 여러함수를 붙이거나 별도의 스크린을 만드는것도 지원하므로 그런 기능을 사용하지 못하는건 아쉽다. 따라서 프로젝트를 매우 유연하게 관리하려는게 아니라면 무섭게 보이는 이 문구는 지워버려 불필요한 오해는 피하고 수동으로 워크플로를 작성하는게 베스트다.</p>

<h2 id="case-3-default-issue-type-scheme">CASE (3) Default issue type scheme</h2>
<p><code class="language-plaintext highlighter-rouge">Issue type scheme</code>은 프로젝트가 어떤 issue들을 사용할지 정의하는 스키마다. 예를 들어 ‘A프로젝트는 버그, 이슈, AS를 사용합니다.’할때 버그, 이슈, AS가 바로 이 스키마다. 기본적으로 Jira에서 프로젝트를 생성하게 되면 자동으로 <code class="language-plaintext highlighter-rouge">Issue types scheme</code>을 생성해 프로젝트마다 하나씩 사용하게 해준다. 하지만 관리자 메뉴에서 할당된 스키마를 제거하거나 <code class="language-plaintext highlighter-rouge">Project settings</code>-<code class="language-plaintext highlighter-rouge">Issue Types</code>-<code class="language-plaintext highlighter-rouge">Actions</code>-<code class="language-plaintext highlighter-rouge">Use a different scheme</code> 메뉴를 통해 바꾸게 되면 <code class="language-plaintext highlighter-rouge">Default issue Type Scheme</code>이란 스키마를 사용하게 된다. (이 이름은 설정에 따라 바뀔 수 있다.) <code class="language-plaintext highlighter-rouge">Default issue Type Scheme</code>엔 지라에서 생성된 모든 Issue가 다 담겨 있고 <code class="language-plaintext highlighter-rouge">edit</code>을 통해 Issue를 뺴거나 지울 수 없는 유일한 특징을 가지고 있다. 모종의 글로벌 변수. 이 global 스키마를 쓰게되면 이슈 종류를 고를때 리스트가 너무 길어지고 사용자들도 어떤 이슈를 써야할지 몹시 난감할것이다. 다만 그런 행정적 이슈 말고는 기술적으론 문제가 되지는 않는다. 각 이슈가 가지는 Screen과 Workflow는 같은 이름의 ‘이슈’라도 프로젝트별로 독립적으로 설정이 되기 때문이다. 따라서 글로벌로 변수를 쓴다해도 너무 걱정할 필요는 없다. <code class="language-plaintext highlighter-rouge">issue Type Scheme</code>는 지울 수 있지만 프로젝트를 생성하면 자신의 프로젝트를 명으로 생성되는 <code class="language-plaintext highlighter-rouge">Default Issue Screen</code>과 <code class="language-plaintext highlighter-rouge">Software Simplified Workflow</code>는 지울 수가 없다. 따라서 안정적으로 각자의 스크린과 워크플로를 적용할 수있다. 하지만 나중에 별도의 이슈 type들만 사용하려고 뒤늦게 <code class="language-plaintext highlighter-rouge">Issue type scheme</code>을 설정하려고 할때는 <code class="language-plaintext highlighter-rouge">Scheme Migration</code>을 거쳐야하고 이때 대시보드의 필터가 뭉게지는 등의 사소한 사이드이펙트를 감수해야하니 global 스키마를 사용하지 않도록 관리하는게 베스트다. 더욱이 ‘Issue’는 workflow와 screen 등 조직의 핵심로직을 담아야하니 글로벌로 쓰는것은 옳지않다.</p>]]></content><author><name>강태훈</name></author><category term="Jira" /><category term="Jira" /><summary type="html"><![CDATA[무엇을 알려주려고 쓰는 글? Jira에서 각자 프로젝트별로 독립된 스키마를 유지하기 위해서 명심하는건 개별 Project 메인화면 - Project settings에서 확인가능한 각 스키마를 단독으로 사용하는지 화면 상단에 Alert 박스로 보이는 Used by n Projects 부분을 잘 확인하면 된다. 단독사용이라면 ‘1’로 보일 것이다. 공통 스키마라면 공통으로 사용중인 프로젝트의 이름이 보일 것이다. 1이 아니라면 스키마를 복제해 독립하면 된다. 하지만 이런 원칙을 지켜도 가끔 프로젝트의 수정이 다른 프로젝트에 영향을 미치기도 하는 게 문제다. 이 글에선 그런 문제를 유발 할 수 있는 지라의 예외적인 케이스와 잘 모르면 오해하기 쉬운 케이스로 “1. 워크플로 내부의 State, Transition 네임수정 2. Simplified workflow 기능 3. Glbal scheme” 를 소개하려고 한다.]]></summary></entry><entry><title type="html">코틀린 튜토리얼 (1) 프로젝트 생성, 빌드, 실행</title><link href="https://hibikequantum.github.io/kotlin/%EC%BD%94%ED%8B%80%EB%A6%B0%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC1" rel="alternate" type="text/html" title="코틀린 튜토리얼 (1) 프로젝트 생성, 빌드, 실행" /><published>2022-11-04T00:00:00+09:00</published><updated>2022-11-04T14:46:00+09:00</updated><id>https://hibikequantum.github.io/kotlin/%EC%BD%94%ED%8B%80%EB%A6%B0%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC1</id><content type="html" xml:base="https://hibikequantum.github.io/kotlin/%EC%BD%94%ED%8B%80%EB%A6%B0%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC1"><![CDATA[<h2 id="시리즈-개요">시리즈 개요</h2>
<p>회사에서 자바 프로젝트를 배포운영하다보니 자주 자바코드를 보는데, 백엔드의 전통이 자바 스프링이라면 다음 시대를 이끌어갈 기술은 뭘까 고민을 하던찰나 코틀린의 여러가지 장점에 대한 설명을 보고 ‘이거다!’ 싶어. 간단한것부터 글로 정리해가고자 시작된 튜토리얼입니다. 문법의 설명은 다른 사이트가 많을테니 목적성을 가지고 글 한나 하나를 적어보려고 합니다. 시리즈 첫번째 주제는 JVM으로 간단한 코틀린 프로그램 실행.</p>

<h2 id="환경구성">환경구성</h2>
<p class="caption">OS: MAC M1 Montery 12.4<br />
실행환경: JVM 18.0.2, Gradle 7.5.1<br />
IDE: IntelliJ CE<br />
<img src="/assets/img/SCR-20221103-uqx.png" alt="" class="align-center" />
Gradle 이 지원하는 JVM을 써야한다. JVM 설치는 IntelliJ의 프로젝트 생성 화면에서 클릭으로도 할 수 있다.</p>

<h2 id="jvm에서-코틀린-프로그램-실행">JVM에서 코틀린 프로그램 실행</h2>
<p class="caption"><img src="/assets/img/SCR-20221103-uyb.png" alt="" class="align-center" />
프로젝트 생성을 위한 기본설정</p>

<p>다음의 값을 설정해준다.<br />
1) 프로젝트 위치, 이름 확인 2) 코틀린 프로젝트 3) Gradle 시스템 4) JDK 선택 5) ‘Add sample code’</p>

<p class="caption"><img src="/assets/img/SCR-20221103-uxk.png" alt="" class="align-center" />
JDK19를 쓰고 싶었지만 Gradle이 지원을 하지 않아서 16을 선택했다.</p>

<p class="caption"><img src="/assets/img/SCR-20221103-v1u.png" alt="" class="align-center" />
생성된 프로젝트</p>

<div class="language-kotlin align-center highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.jetbrains.kotlin.gradle.tasks.KotlinCompile</span>

<span class="nf">plugins</span> <span class="p">{</span>
    <span class="nf">kotlin</span><span class="p">(</span><span class="s">"jvm"</span><span class="p">)</span> <span class="n">version</span> <span class="s">"1.7.10"</span>
    <span class="n">application</span>
<span class="p">}</span>

<span class="n">group</span> <span class="p">=</span> <span class="s">"org.example"</span>
<span class="n">version</span> <span class="p">=</span> <span class="s">"1.0-SNAPSHO"</span>

<span class="nf">repositories</span> <span class="p">{</span>
    <span class="nf">mavenCentral</span><span class="p">()</span>
<span class="p">}</span>

<span class="nf">dependencies</span> <span class="p">{</span>
    <span class="nf">testImplementation</span><span class="p">(</span><span class="nf">kotlin</span><span class="p">(</span><span class="s">"test"</span><span class="p">))</span>
<span class="p">}</span>

<span class="n">tasks</span><span class="p">.</span><span class="nf">test</span> <span class="p">{</span>
    <span class="nf">useJUnitPlatform</span><span class="p">()</span>
<span class="p">}</span>

<span class="n">tasks</span><span class="p">.</span><span class="n">withType</span><span class="p">&lt;</span><span class="nc">KotlinCompile</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="n">kotlinOptions</span><span class="p">.</span><span class="n">jvmTarget</span> <span class="p">=</span> <span class="s">"1.8"</span>
<span class="p">}</span>

<span class="nf">application</span> <span class="p">{</span>
    <span class="n">mainClass</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s">"MainKt"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p class="captionC">build.gradle.kts</p>
<p>Gradle은 앱을 빌드 및 구성해주는 시스템<a href="https://mkil.tistory.com/479">참조블로그</a>. DSL(Domain Specific Lanuage)로 쓰인 ‘build.gradle.kts’는 무엇을 어떻게 빌드할지 정의하는 레시피다. this 항목들은 <code class="language-plaintext highlighter-rouge">org.gradle</code>패키지를 가르키고 있다. 빌드 시스템이 동작하면 gradle이 먼저 선행되 JVM과 Dependencies를 소화한 뒤 <code class="language-plaintext highlighter-rouge">Main.kt</code>를 읽어들이게 된다. 빌드 결과물은 <code class="language-plaintext highlighter-rouge">target</code> 디렉토리에 저장되고 JVM 위에서 실행된다.</p>

<p class="caption"><img src="/assets/img/SCR-20221104-el6.png" alt="" class="align-center" /></p>
<p><code class="language-plaintext highlighter-rouge">RUN &gt; Edit Configuration</code>에서 프로그램 실행환경을 설정한다. 1) MainApp이란 이름으로 2) Main.kt 프로그램을 실행하도록 패키지를 선택했다. 이제 <code class="language-plaintext highlighter-rouge">RUN &gt; Run MainApp</code>을 하면 프로그램이 실행된다.</p>

<p class="caption"><img src="/assets/img/SCR-20221104-evo.png" alt="" class="align-center" />
글에 적진 않았지만 leadln()을 이용해 입력을 받고 출력하는 코드를 추가했다.</p>

<p>이걸로 프로젝트 생성부터 실행까지 진행했다. 다음부터는 자바를 하는 이유인 Spring 을 코틀린으로 작성해서 서비스 해보려고 한다.</p>]]></content><author><name>강태훈</name></author><category term="kotlin" /><category term="kotlin," /><category term="tutorial" /><summary type="html"><![CDATA[시리즈 개요 회사에서 자바 프로젝트를 배포운영하다보니 자주 자바코드를 보는데, 백엔드의 전통이 자바 스프링이라면 다음 시대를 이끌어갈 기술은 뭘까 고민을 하던찰나 코틀린의 여러가지 장점에 대한 설명을 보고 ‘이거다!’ 싶어. 간단한것부터 글로 정리해가고자 시작된 튜토리얼입니다. 문법의 설명은 다른 사이트가 많을테니 목적성을 가지고 글 한나 하나를 적어보려고 합니다. 시리즈 첫번째 주제는 JVM으로 간단한 코틀린 프로그램 실행.]]></summary></entry><entry><title type="html">2022.11.04 TIL &amp;amp; Diary</title><link href="https://hibikequantum.github.io/til/P2-TIL-71" rel="alternate" type="text/html" title="2022.11.04 TIL &amp;amp; Diary" /><published>2022-11-04T00:00:00+09:00</published><updated>2022-11-04T11:15:38+09:00</updated><id>https://hibikequantum.github.io/til/P2-TIL-71</id><content type="html" xml:base="https://hibikequantum.github.io/til/P2-TIL-71"><![CDATA[<p class="caption"><img src="/assets/img/DALL·E 2022-10-05 15.17.33 - A picture of Nyan cat and doggy reconciling.png" alt="!!!" class="simg" />
From dalle</p>

<h2 id="language">Language</h2>
<p>코틀린 프로젝트 블로그 쓰고 파이선 연습문제 4문제를 풀었다.</p>

<h2 id="english">ENGLISH</h2>
<p>영어회화앱으로 20분 나머지는 문법책을 처리했다. 영어로만 회화하는 모임에 가입해서 토요일에 첫 온라인 모임, 일요일은 오프라인 미팅에 참석할 예정</p>

<h2 id="diary">Diary</h2>
<p>요즘은 일단 자기자신에 대해 생각하지 않기로해서 다이어리 부분은 한동안 쓰지 않을 예정이다.</p>

<h2 id="life">Life</h2>
<ul>
  <li>움직인 시간: 0.5H</li>
  <li>습관 일기:<br />
나쁜 습관 없애기 Phase 1 - 일차</li>
  <li>생체배터리: 50% -&gt; 0%</li>
  <li><a href="">🔗<strong>일일메모장 커밋</strong></a></li>
</ul>]]></content><author><name>강태훈</name></author><category term="TIL" /><category term="TIL,DAIRY" /><summary type="html"><![CDATA[간만에 쓰는 TIL]]></summary></entry><entry><title type="html">데브옵스 핸드북을 읽고</title><link href="https://hibikequantum.github.io/devlog/%EB%8D%B0%EB%B8%8C%EC%98%B5%EC%8A%A4-%ED%95%B8%EB%93%9C%EB%B6%81-%ED%9B%84%EA%B8%B0" rel="alternate" type="text/html" title="데브옵스 핸드북을 읽고" /><published>2022-10-06T00:00:00+09:00</published><updated>2022-10-06T14:34:41+09:00</updated><id>https://hibikequantum.github.io/devlog/%EB%8D%B0%EB%B8%8C%EC%98%B5%EC%8A%A4%20%ED%95%B8%EB%93%9C%EB%B6%81%20%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="https://hibikequantum.github.io/devlog/%EB%8D%B0%EB%B8%8C%EC%98%B5%EC%8A%A4-%ED%95%B8%EB%93%9C%EB%B6%81-%ED%9B%84%EA%B8%B0"><![CDATA[<p class="caption"><img src="/assets/img/IMG_3023.jpeg" alt="" class="mimg" />
책 전면</p>

<h2 id="왜">왜</h2>
<p>4월부터 배포 파이프 라인을 관리하는 일을 시작했다. 따라서 직무를 둘러싼 줄기를 일단 파악하려고 산 책이다. 개인적으론 데브옵스를 IT만의 이슈라고 생각했는데 책의 내용을 보면 도요타에 대한 이야기가 참 많이 나오는 게 대학시절로 돌아간 기분이 들었다. 도요타는 현대적 제조업 경영의 스탠더드를 성립한 회사였고 그 지위를 아직도 뺏기지 않은 최고의 프랙티스다. 최근엔 테슬라를 공부해본 투자자들이 SW뿐만 아니라 제조관리도 테슬라의 강점이 있다는 이야기를 들었는데 나중에 별도로 공부해볼 만한 이슈다.</p>

<h2 id="누구를-위한-책">누구를 위한 책</h2>
<p>그렇다고 이 책이 공장을 포함하는 광범위한 범위를 다루는 책은 아니다. 이 책을 통해 향상하려는 프랙티스는 분명히 IT서비스 개발과 운영이다. 나아가 고객에게 가치를 Delivery 하는 최종 접점을 향하여 조직운영을 혁신하는 방법을 다루는 책이다. 여기엔 개발과 배포를 어떻게 할 것인지에 대해 필요한 원칙, 전술적 방법, 전략적 지향점이 포함되어 있다. 따라서 이런 실행을 위해 사용되는 오픈소스나 방법론 소프트웨어 이념 등이 짤막하게 등장할 뿐이지 코드나® 코드를 짜는데 참고할만한 플로우 차트는 일절 없다. (사실 핸드북이라길래 그런 것도 있는 줄 알았다)
이 책은 조직운영에 대한 이야기가 주류를 이룬다. 주니어들도 읽어보면 도움은 될 수도 있지만, 조직의 문화를 관리하며 관행을 컨트롤할 수 있는 위치에 있는 이사들이나 시니어들에게 필요한 조언이 중심이 된다. 물론 팔로워도 자신들이 뭘 팔로우하는 건지는 알아야 하지 않겠는가. 때문에 이 책은 누구에게나 도움이 될 거라 생각한다.</p>

<h2 id="이-책에서-제시하는-전략의-큰-덩어리">이 책에서 제시하는 전략의 큰 덩어리</h2>
<ul>
  <li>(개발에서 고객까지) 작업흐름을 가속하기</li>
  <li>(고객에서 개발까지) 피드백을 가속하기</li>
  <li>(실패할 때만 배우는 건 부족하다) 학습과 실험을 유발하기</li>
</ul>

<p>끝! 핵심만 따지면 이거다. 그리고 나머지 덩어리들은 논지를 부드럽게 하고 전략을 완성하기 위한  전술들의 나열이다. 그리고 거기 포함된 주요한 키워드들은 다음과 같다.</p>

<p>유의미한 개선 목표 설정, 콘웨이의 법칙, WIP 리밋을 걸기, 배치작업 크기 줄이기, 느슨하게 연결된  컴포넌트 설계, 스워밍 활동, 6개월 전에 망가뜨린 것을 책하지 말고 몇 분내에 피드백을 제공하기, 휴먼에러를 배제하는 설계(건프라 조립을 해보면 이런 게 보인다), 비난 없는 포스트모템, 지역적 발견을 전체의 개선으로 전환(미 해군 원자로 운영에 쓰는 지식공유체계 사례가 나온다),  카오스 몽키, 게임데이, 리더와 팔로워는 서로를 필요로 한다(리더는 실무를 하지 않고, 팔로워는 일의 맥락과 권한이 없다), 그린필드, 브라운필드, 가장 혁신적인 그룹부터 데브옵스를 시작하라, 작은 물고기는 작은 연못에서 큰 물고기가 되는 법을 배운다, 가치흐름 매핑 생성, 개선활동은 기술 부채를 제거하기 위한 세금, 두 달 동안 신규 기능 개발을 중단하겠다고 말해야 했던 리더의 용기, 팀원들이 제너럴리스트가 되어야 한다, 긍정적 혼란의 촉진, 피자 두 판의 법칙, 자체 서비스 운영 플랫폼이 없으면 클라우드는 비싼 호스팅 2.0, 개발회의에 운영을 초청하기, 자동화할 수 있는 업무, Singgle source of truth, 복구보다는 재구축이 쉬운 인프라가 좋다, 테스트 자동화를 위한 설계, 두려움은 정신의 살인범, 안돈 코드, 병합 난이도를 올리는 기존 깃 플로우, 트렁크 기반 개발 패러다임(이 책에서 가장 재밌게 봤던 부분이다), 배포 프로세스 자동화를 위한 전술, 스모크 테스트, 개발에게 셀프 배포를 할 수 있게 하라, 블루-그린 배포 전략, 여러 버전의 앱을 요청을 다 처리할 수 있도록 유연하게 구성, 다크런치, 페이스북 게이트키퍼, 마이크로 서비스, 교살자 애플리케이션 패턴, “모든 상황에 적합한 아키텍처는 없다. 서비스 크기가 x1 x10 x100 이 될 때마다 각각의 답이 존재한다”, culture of causalty, LRR과 HRR의 사용 - (운영으로 핸드 오프전 사전 체크리스트의 운영), A/B 테스트, 모든 활동에 달러 가치를 부여한 CEO, 변경 크기와 위험은 비선형적 관계에 있다. 자주 통합을 해야 하는 이유, just culture(고의가 아니면 용서한다), 프로덕션에 실패 주입, “지속 가능한 경쟁우위는 더 빨리 배우는 능력뿐”</p>

<h2 id="트렁크-기반-개발">트렁크 기반 개발</h2>
<p>하나하나 다 소개할 수는 없고 생각이 다 이야기할 수는 없다. 상당히 광범위한 내용을 다루는 책이다 보니 무엇을 앵커로 잡아야 할까 고민이 많이 되는데 지금 당장 머릿속에 강렬하게 남은 이미지는 트렁크 기반 개발 패러다임이다. 지금까지 깃 플로우 말고 다른 전략이 있다고 생각도 못하고 있었는데 HP 프린터 개발자들이 도입한 이 전략은 논쟁적이나 이 책에서 좋다고 추천하고 있다.(더 찾아보니 무려 역사가 20년!! 짧다면 짧다) 트렁크 기반 개발을 하면 기존 깃 플로우와 다른 점은 다음과 같다.</p>

<ul>
  <li>기능 개발, 디버그 등 작업별로 브랜치를 만들지 않는다.</li>
  <li>Trunk(Main, Master)에 직접 커밋한다.</li>
  <li>브랜치가 생성되는 유일한 지점은 운영으로 배포할 때다.</li>
</ul>

<p>이 전략은 작업의 격리성을 떨어트려 작은 변경이 개발자 모두에게 영향을 끼치게 된다. 하지만 별도의 머지 작업이 없고 관리 포인트를 극단적으로 줄여준다. 따라서 이 전략을 쓰는 팀은 각각의 커밋이 유효하게 동작할 수 있도록 유기적으로 협력을 해야 하고 안전을 위한 다음의 룰을 준수해야 한다.</p>

<ul>
  <li>상시적 페어 프로그래밍</li>
  <li>커밋된 트렁크가 항상 빌드될 수 있음을 보장하는 효과적 파이프라인</li>
  <li>소규모 배치 작업</li>
</ul>

<p>굉장히 매력적이고 충격적인 작업방식인 만큼 트렁크 기반 개발은 개인적으로 더 공부해볼 예정이다.</p>

<h2 id="직무-융합의-시대">직무 융합의 시대</h2>
<p>데브옵스를 바라보는 이 책의 내용에서 한 발자국 물러나 이 책이 설명하고 있는 전략에 대해 이야기해보자. 개발과 운영이 더 긴밀하게 붙는 현상. Convergence라 불러도 손색이 없는 트렌드는 devops에서만 벌어지는 일이 아니다. 아니라 개발자 내에서도, 아티스트 업에서도, 영업과 PR에서도 벌어지고 있다고 들었다. 내가 생각하기에 원인은 다음과 같다.</p>

<ul>
  <li>기술의 발전으로 한 사람이 더 많은 일을 할 수 있음</li>
  <li>직무의 명확한 구분에서 오는 이익보다 일을 다음 사람에게 전달하고 피드백하는 비용이 더 큼</li>
  <li>명확한 구분이 필수적인 책임과 계약을 중심으로 이뤄지는 활동은 관료화의 원인</li>
  <li>느슨한 결합과 그 결합을 조율하는 융합적 인간과 조직 구성이 생산성 향상에 도움이 됨.</li>
</ul>

<p>융합의 시대에 나는 뭘 할 수 있을까? 어디로 가야 할까? 스페셜리스트를 지나 다시 제너럴리스트의 시대? 제너럴 한 것은 비용을 줄이는 접근(예를 들어 AI)에서 자유로울 수 없으니까. 그런 고민이 깊어지는 밤이다.</p>]]></content><author><name>강태훈</name></author><category term="devlog" /><category term="Eengineer" /><category term="General" /><summary type="html"><![CDATA[책 전면]]></summary></entry><entry><title type="html">2022.09.06 TIL &amp;amp; Diary</title><link href="https://hibikequantum.github.io/til/P2-TIL-70" rel="alternate" type="text/html" title="2022.09.06 TIL &amp;amp; Diary" /><published>2022-09-06T23:53:11+09:00</published><updated>2022-09-06T23:53:14+09:00</updated><id>https://hibikequantum.github.io/til/P2-TIL-70</id><content type="html" xml:base="https://hibikequantum.github.io/til/P2-TIL-70"><![CDATA[<p class="caption"><img src="/assets/img/DALL·E 2022-08-31 23.08.06 - Anthony Browne style, cat studying English.png" alt="!!!" class="simg" />
from dalle</p>

<h2 id="language">Language</h2>
<p>어찌어찌 하나 따라해보고 싶었떤 MVC 모델 구축은 끝까지 해봤고, 구축된 소스코드를 읽는중. 커밋은 어떻게 관리하고, 워크플로우랑 연결 했을때 태스크를 잘라서 하는지도 보고. annotation의 활용을 제대로 못하면 컴파일 단계에서 에러가 많이 나는게 참 불편하다. django도 나름 신경쓸게 많다고 생각했는데 진짜는 스프링이네.</p>

<h2 id="english">ENGLISH</h2>
<p>solasta 3일차. 다 아는 단어인데 회화에서 쓸때는 익숙하지 않게 배치를 하는게 많아 이해가 안되는 문장들이 많다. 익숙해질때까지 자주 보는게 답이겠지.</p>

<h2 id="diary">Diary</h2>
<p>내일까지 유지칼로리 먹으면 다이브레이크 일정 끝. 운동도 다시 시작이다.</p>

<h2 id="life">Life</h2>
<ul>
  <li>움직인 시간: 0.5H</li>
  <li>습관 일기:<br />
나쁜 습관 없애기 Phase 5 - 일차</li>
  <li>생체배터리: 50% -&gt; 40%  이제 지나치게 무기력한건 좀 사그라든듯 하다.</li>
  <li><a href="https://github.com/HibikeQuantum/PlayGround/commit/ba6c3b0d9e93a85a4b70626e7fe076655e3b1a31">🔗<strong>일일메모장 커밋</strong></a></li>
</ul>]]></content><author><name>강태훈</name></author><category term="TIL" /><category term="TIL,DAIRY" /><summary type="html"><![CDATA[from dalle]]></summary></entry><entry><title type="html">2022.09.05 TIL &amp;amp; Diary</title><link href="https://hibikequantum.github.io/til/P2-TIL-69" rel="alternate" type="text/html" title="2022.09.05 TIL &amp;amp; Diary" /><published>2022-09-05T00:00:00+09:00</published><updated>2022-09-06T00:35:14+09:00</updated><id>https://hibikequantum.github.io/til/P2-TIL-69</id><content type="html" xml:base="https://hibikequantum.github.io/til/P2-TIL-69"><![CDATA[<p class="caption"><img src="/assets/img/DALL·E 2022-08-28 21.55.51 - excess rome people, Botticelli syle. .png" alt="!!!" class="simg" />
from dalle</p>

<h2 id="language">Language</h2>
<p>JPA 연결해서 스프링 데이터 연결하는 내용 진행헀다. 뭐 잘 안되는거 이것저것 고치다 보니 시간이 다 흘러가버렸다. 하루를 마무리 하는 시점에서 되돌아보니 허망하다..</p>

<h2 id="english">ENGLISH</h2>
<p>오늘도 솔라스타 플레이. 점점 소설이 보고싶어진다. 너무 답답하다. 게임 자체도 재미없다.</p>

<h2 id="diary">Diary</h2>
<p>처음 정열이 지배하는 시간을 마치고 의무감에 이끌려 하다가 점점 의욕을 잃는 경험. 한 두 번도 아니고 어떻게 이런걸 바라봐야할지. 지금은 너무 심각하게 독단적으로 판단 하지 말고 조금씩 0.5보씩만 걸으면서 뭔가 다른 방법과 다른 의견을 들어볼때다. 지금까지는 그게 문제였다. ‘독단적으로 빨리 결론을 내린것’</p>

<h2 id="life">Life</h2>
<ul>
  <li>움직인 시간: 0.5H</li>
  <li>습관 일기:<br />
나쁜 습관 없애기 Phase 4 - 일차</li>
  <li>생체배터리: 50% -&gt; 20%</li>
</ul>]]></content><author><name>강태훈</name></author><category term="TIL" /><category term="TIL,DAIRY" /><summary type="html"><![CDATA[JPA, 허망하도다 허망해, 의욕씨 어디로 갔어요]]></summary></entry><entry><title type="html">2022.09.04 TIL &amp;amp; Diary</title><link href="https://hibikequantum.github.io/til/P2-TIL-68" rel="alternate" type="text/html" title="2022.09.04 TIL &amp;amp; Diary" /><published>2022-09-04T00:00:00+09:00</published><updated>2022-09-05T00:17:05+09:00</updated><id>https://hibikequantum.github.io/til/P2-TIL-68</id><content type="html" xml:base="https://hibikequantum.github.io/til/P2-TIL-68"><![CDATA[<p class="caption"><img src="/assets/img/DALL·E 2022-08-31 23.08.01 - Anthony Browne style, cat studying English.png" alt="!!!" class="simg" />
from dalle</p>

<h2 id="philosophy">Philosophy</h2>
<p>거대한 전환 읽는중. 1장부터 계속 고전주의 경제학자들이 (내가 학교에서 배운) 신줏단지처럼 모시는 자본주의 교리(특히 자본주의가 인간 본성에 부합한다)에 대한 비판을 많이 한다. 그런 비판의 근거가 대학생 시절에 진보적 신문에서 보던 논리보단 훨씬 논리적인게 마음에 든다. 인간본성이 사회주의에 가깝다는건 이 사람이 책을 쓸 무렵에도 많이 증명된 모양인데 그걸 너무나도 당연하게 받아들이고 그 본성을 억누르고 사유재산을 확립시킨게 발전의 계기였다라고 배운 나로선. 뭔가 100년전에 울린 echo가 지금 도착한 기분이 든다. 책쓴 아저씨! 그 정돈 나도 알아!</p>

<h2 id="english">ENGLISH</h2>
<p>Solasta란 판타지 CRPG 게임을 영문으로 해봤다. 생각보다 텍스트가 별로 없는 게임이라 (퀘스트 스크립트도 올드스쿨에 비하면 짧고 룰도 단순해서 description이 짧다) 읽는 시간과 머리 굴리며 게임하는 시간의 비율이 생각보다 안나온다. 난이도를 엄청 쉽게 해서 거의 스토리읽듯이 하면 해결될것 같긴하다. 공부할 때는 현대적 배경의 소설을 읽는게 최고일거 같다. (예전에 왜 일리아드 영문판을 사서 읽었을까)</p>

<h2 id="diary">Diary</h2>
<p>만족할만큼 기분좋은 하루는 아니었지만 뭔가 아침점심때 기분이 너무 꽝이었다가 저녁이 되니까 많이 기분이 좋아졌다. 조금씩 좋아지면 되지 뭐. 기분을 좋아지는 루틴을 발굴하자.</p>

<h2 id="life">Life</h2>
<ul>
  <li>움직인 시간: 2H</li>
  <li>습관 일기:<br />
나쁜 습관 없애기 Phase 3 - 일차</li>
  <li>생체배터리: 40% -&gt; 20%</li>
  <li><a href="https://github.com/HibikeQuantum/PlayGround/commit/7c6cf26a44d7e7135086906dc5a9ff8295925ed2">🔗<strong>일일메모장 커밋</strong></a></li>
</ul>]]></content><author><name>강태훈</name></author><category term="TIL" /><category term="TIL,DAIRY" /><summary type="html"><![CDATA[거대한 전환, Solasta]]></summary></entry><entry><title type="html">2022.09.03 TIL &amp;amp; Diary</title><link href="https://hibikequantum.github.io/til/P2-TIL-67" rel="alternate" type="text/html" title="2022.09.03 TIL &amp;amp; Diary" /><published>2022-09-03T23:56:15+09:00</published><updated>2022-09-03T23:56:18+09:00</updated><id>https://hibikequantum.github.io/til/P2-TIL-67</id><content type="html" xml:base="https://hibikequantum.github.io/til/P2-TIL-67"><![CDATA[<p class="caption"><img src="/assets/img/DALL·E 2022-08-28 21.56.03 - excess rome people, Botticelli syle. .png" alt="!!!" class="simg" />
from dalle</p>
<h2 id="devops">Devops</h2>
<p>데브옵스 핸드북. 오늘 읽은 내용은 비교적 실무에 적용가능한 지침에 대한 내용들이었다. Single one truth에 대한 고집, 복구보단 재구축에 대한 선호. 성능 테스트를 단위테스트에서 수행하는 등 예전에 CTO분께서 강조했던 점들을 조금씩 납득해가는중. 중요한건 당장 코드를 쓰는게 아니라 규율있는 조직의 시스템이었던것.<br />
그런 와중에 뭔가 머리를 띵하고 충격을 줬던게 Trunk기반 개발에 대한 극찬. 당연히 그게 열등해서 git flow가 탄생한것으로 알고 있었는데 반대로 그걸 trunk를 기반으로 병합에 들어갈 에너지를 다 쳐내 더 많은 릴리즈를 지향하는 조직이 있다니. 그리고 그게 더 좋다고 이 책은 증언하고 있다니. 회사의 trunk 배포시스템을 다시 해석해볼 필요가 생겼다.</p>

<h2 id="philosophy">Philosophy</h2>
<p>거대한 전환, 오늘은 기계도입이 사회의 속성을 결정 지었다는 저자의 주자으로 시작. 4장에서 그 주장을 증명하기 전에 시장경제라는 것이 절대로 인류의 보편적 욕망과 이해가 아니었음을 설명하는 내용을 읽었다. 그 중에 쿨라 무역에 대한 이야기를 했는데 거기 대한 내 잡생각은 트위터에 <a href="https://twitter.com/Hibike_Quantum/status/1566073825590095873">링크</a></p>

<h2 id="diary">diary</h2>
<p>주말 아침은 청소도 하고 병원도 가고 다 마무리하고 집에와서 씻고 책을 보면 그렇게 좋을 수가 없는데 오늘은 점뺏다고 세수도 못하고 찝찝하게 책만 봤다. 대신 물에 젖은 수건으로 살살 세수를 했는데. 뭔가 5살인가.. 천식 때문에 고생하던 시절에 병원에서 어머니가 해준것 같기도해서 아련하다.</p>

<h2 id="life">Life</h2>
<ul>
  <li>움직인 시간: 1H</li>
  <li>습관 일기:<br />
나쁜 습관 없애기 Phase 2 - 일차<br />
뭉갠시간 3시간. 이제 줄이면 되!</li>
  <li>생체배터리: 60% -&gt; 25%</li>
  <li><a href="https://github.com/HibikeQuantum/PlayGround/commit/3d3b3a77c1d4fa0ebf7f57d391b29dc9d79db1b3">🔗<strong>일일메모장 커밋</strong></a></li>
</ul>]]></content><author><name>강태훈</name></author><category term="TIL" /><category term="TIL,DAIRY" /><summary type="html"><![CDATA[from dalle Devops 데브옵스 핸드북. 오늘 읽은 내용은 비교적 실무에 적용가능한 지침에 대한 내용들이었다. Single one truth에 대한 고집, 복구보단 재구축에 대한 선호. 성능 테스트를 단위테스트에서 수행하는 등 예전에 CTO분께서 강조했던 점들을 조금씩 납득해가는중. 중요한건 당장 코드를 쓰는게 아니라 규율있는 조직의 시스템이었던것. 그런 와중에 뭔가 머리를 띵하고 충격을 줬던게 Trunk기반 개발에 대한 극찬. 당연히 그게 열등해서 git flow가 탄생한것으로 알고 있었는데 반대로 그걸 trunk를 기반으로 병합에 들어갈 에너지를 다 쳐내 더 많은 릴리즈를 지향하는 조직이 있다니. 그리고 그게 더 좋다고 이 책은 증언하고 있다니. 회사의 trunk 배포시스템을 다시 해석해볼 필요가 생겼다.]]></summary></entry></feed>